

**********************************************************************************************************************

*  Production Function OutputGAP

* Information on changes over the years is added at the end
* Information on the program is added as *I*


**********************************************************************************************************************


source 'H:/Documents/My Documents/Winrats/bjfore.src'


*============
* Parameters
*============
*============

	*I* vectors, integers or strings are defined

declare vector[strings] veclabelvar veccodevar
declare vector[integer] vecvar      vecco
declare vector[labels]  co
declare integers        changey     endy        dstarty  	dendy  	check  	yf
declare string          selectmsg   alertmsg 	inputtfpmsg


*** country selection ***
***                ***

	*I* list of countries, the number of countries (nco) is calculated and a box is made so that people can choose a country but not same result as all selected

compute co      = ||'be','de','dk', 'el','es','fr','ie','it', 'lu','nl','at','pt','fi', 'se', 'uk','cz','ee','hu','lv','lt','pl','sk','si','cy','mt','bg','ro','hr','us' ||
compute codes   = ||'be','de','dk', 'el','es','fr','ie','it', 'lu','nl','at','pt','fi', 'se', 'uk','cz','ee','hu','lv','lt','pl','sk','si','cy','mt','bg','ro','hr','us' || ;


compute nco     = %rows(co)
compute [integer] onecountry = 0

dbox(action=define, title = "Country Mode Selection")
dbox(stext="SINGLE country mode or ALL countries (Default if none selected)? ")    ;*Single country: run the first country selected
dbox(scrollbox,strings=codes) vecco
dbox(action=run,status=dboxok)

if vecco(1).and..not.vecco(nco) {
   compute onecountry = 1
   compute nco        = 1
   compute co(1)      = co(vecco(1))
  }
end if


*** time range 	***
***		***

	*I* the time range is defined, the 'changey' is the most important exogenously set year, the rest is based on this 'changey'
	*I* changey is t+2
	*I* yf stands for years of forecast, dstarty: start year for display, dendy: end year for display

compute changey  = 2020, yf = 3, dstarty = 1965, defaultdates = 0 ;*** default values ***
compute endsample   = 2050

	*I* Allow to choose other dates, a pop up dialog is created

compute alertmsg1 = 'Do you want to calculate the t+5 forecast? ' +  $
						 '\\  Last year of data: '+ changey + $
                   '\\  Med-term extension: '+ yf +' years'
messagebox(style =yesno, status=defaultdates1) alertmsg1

if defaultdates1 == 0 {                  ;* manual setting of dates

compute alertmsg2 = 'Do you want to calculate the t+10 forecast? ' +  $
						 '\\  Last year of data: '+ changey + $
                   '\\  Med-term extension: 8 years'
messagebox(style =yesno, status=defaultdates2) alertmsg2
if defaultdates2 == 1
	{
	compute yf = 8
	}
							}
end if

	if defaultdates2 == 0.and.defaultdates1 == 0 {
	   query(prompt = 'What is the last year of data (default is 2018) :',initialize)                      changey
	   while changey<2000.or.changey>2025
         query(prompt = 'Final year for data (should be between 2000 and 2025 !!) :',initialize)          changey
         query(prompt = 'How many years should be forecast (default is 3 for t+5 and 8 for t+10) :',initialize)                  yf
      while yf<=0.or.yf>45
         query(prompt = 'How many years to be forecast ( < 45) :',initialize)                             yf
   *      query(prompt = 'Choose the starting year for display (default is 1981) :', status=OK,initialize) dstarty
   *   while dstarty < 1965.or.dstarty>changey+yf
   *      query(prompt = 'Starting year for display (must be > 1964 !!) :')                                dstarty
   *      query(prompt = 'Choose the end year for display (default is 2021):', status=OK,initialize)       dendy
   *   while dendy < 1981
   *      query(prompt = 'Check END year for display :')                                                   dendy
   *   while dendy > changey+yf+3
   *       query(prompt = 'End year of display (must be within forecast years !)')                         dendy
   *   while dendy < dstarty
   *       query(prompt = 'Check and give start and end year of display')                                  dstarty dendy ;
     }
   end if



	*I* we want to create a forecast which goes 3 years longer (thus yf = 3+yf) to avoid end point bias
	*I* the last year can be calculated based on the changey (exogenously set) + total number of years forecasting

compute yf      = 3       + yf
compute endy    = changey + yf
compute beginfy = changey + 1
compute dendy 	= changey + yf - 3
compute endt5 	= changey+3+3
compute t6	= changey + 4

display "changey " changey "beginfy " beginfy "t6 " t6 "endt5 " endt5 "endy " endy

	*I* Creation of the variables for computing the Kf TFP (further processing by the GAP program)
	*I* only used in the t+5 framework

if yf<=6 {
	compute inputTFPmsg = 'Do you want to prepare the TFP (input) series ?'
	messagebox(style =yesno, status=TFPinput) inputTFPmsg
			}


*** Display ***
***         ***

* standard CONSTRUCT choice:

	*I* labels and codes are given to several variables. these can be selected as output and they should correspond

compute veclabelvar = ||'GDP',                     $
                        'Trend_GDP',               $
                        'Y_Gap(PF)',               $
                        'Y_Pot',                   $
                        'Part',                    $
                        'Part_S',                  $
                        'Y_Gap(HP)',               $
                        'wSR',                     $
                        'wSR_KF',                  $
                        'NAWRU',                   $
                        'UnEmpl_Rate',             $
                        'HperE',                   $
                        'Investment',              $
                        'Pot_LF',                  $
                        'Pot_Empl',                $
                        'Pot_Tot_Hrs',             $
                        'Empl',                    $
                        'Tot_Hrs',                 $
                        'Capital',                 $
                        'Wage_Infl',               $
                        'Civ_Empl',                $
                        'Pop_WA',                  $
                        'Tot_Pop',                 $
                        'SR',                      $
                        'SR_HP',                   $
                        'SR_Kf',                   $
                        'Depreciation rate',       $
                        'Exchange rate',           $
                        'PPS',                     $
                        'GDP deflator_euro',       $
                        'Nominal_GDP-euro',        $
                        'NULC'                     ||

compute veccodevar  = ||'y',                       $
                        'yhp_',                    $
                        'ygap',                    $
                        'ypot',                    $
                        'part_mt',                 $
                        'parts',                   $
                        'ygaphp_',                 $
                        'wsr',                     $
                        'wsrKF',                   $
                        'nawru',                   $
                        'lurharm',                 $
                        'hpere_mt',                $
                        'iq',                      $
                        'lfss',                    $
                        'lp2',                     $
                        'totalhs',                 $
                        'l_mt',                    $
                        'totalh_mt',               $
                        'k',                       $
                        'winf',                    $
                        'sle',                     $
                        'popw',                    $
                        'popt',                    $
                        'sr',                      $
                        'srhp',                    $
                        'srKF',                    $
                        'dep',                     $
                        'erate',                   $
                        'pps',                     $
                        'gdpdefle',                $
                        'nomye',                   $
                        'nulc'                     ||


select(strings=veclabelvar, status = selectOK,    $
       prompt='Select the variables you would like to display (default is 20 main VARIABLES with comparison)' ) nvar vecvar
if .not.selectOK.or.nvar.eq.0
   compute nvar = 10, vecvar = ||1,2,3,4,5,6,7,8,9,12,13,14,18,19,26,33,34,37,41,42|| ;*** default value : 20 VARIABLES ***
end if


*** standard graphs and excel tables by country
	*I* for some purposes one might need extra output files. you can select them here

compute [integers] printgraph = 0, savegraphs = 0, excel = 0, excelbis = 0, excelter = 0
if .not.TFPinput {
	messagebox(style=yesno, status=excel)      'Do you want standard xls files (by country) to be prepared ?'
*	messagebox(style=yesno, status=printgraph) 'Do you want standard graphs to be prepared ?'
*	messagebox(style=yesno, status=excelbis)   'Do you want xls files (by country) with Output Gap decomposition (1966-end ST)?'
*	messagebox(style=yesno, status=excelter)   'Do you want xls files (by country) with Potential Growth decomposition (1966-end MT)?'
	}
end if




*==========================
* Loop over the countries
*==========================

	*I* create a variable indicating the number of series to be uploaded

compute [integer] nombreseries = 25

	*I* in rats you NEED to define a calendar (with the starting year)
	*I* the allocate is used to create a table (tableaux)

CALENDAR 1960
ALLOCATE nombreseries endsample:1
declare rectangular[series] tableaux(nvar,nco) tableaux2(nco,nvar);

	*I* creation of a file with TFP data for further processing by the GAP program

declare vector[series]      inputTFP(nco) hptrendTFP(nco);
declare series              wsr110  wsr210 wsr310 wsr010 wsr010s wsr010d wsr011  wsr012 wsr211 wsr221 hpere110 dhpere110 dhpere010 dhpere010d hpere010 dhpere011
declare series              wsrhpold dep_ee dep_lt

set time        = t


	*I* from here a loop starts, to cover all countries (from country 1 to nco countries)

*===================
do ic=1,nco
*===================

	*I* the table that we want with results is defined, using the labels from before

do i=1,nvar
	labels tableaux(i,ic);
	# co(ic)+'_'+veclabelvar(vecvar(i))
	labels tableaux2(ic,i);
	# co(ic)+'_'+veclabelvar(vecvar(i))
end do i


*-------------
* 1. DATA READING
*====================

	*I* because we have a loop, the reading of data is a bit more complicated and it uses labels 1 to nombreseries (also defined above)
	*I* the names need to be exactly the same as in your input files

labels 1 to nombreseries
# co(ic)+'_gdpq'	co(ic)+'_iq'       	co(ic)+'_in'		co(ic)+'_kt'		$
co(ic)+'_lur' 		co(ic)+'_hwcdw'		co(ic)+'_hpere'   	co(ic)+'_sled' 	  	$
co(ic)+'_popa1'         co(ic)+'_popt' 		co(ic)+'_popaf' 	co(ic)+'_poptf'  	$
co(ic)+'_nawru'  	co(ic)+'_srkf'  	co(ic)+'_er'     	co(ic)+'_ppp'    	$
co(ic)+'_pgde'          co(ic)+'_gdpne' 	co(ic)+'_nulc'    	co(ic)+'_sle' 		$
co(ic)+'_awgdpart'	co(ic)+'_partM'		co(ic)+'_popwM'   co(ic)+'_sle1' $
co(ic)+'_dep'

	*I* because we are in a loop, we need to clear all data points

clear 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  19 20 21 22 23 24 25
clear wsr110 wsr210 wsr310 wsr010 wsr010s wsr010d wsr011 wsr012 wsr211 wsr221 wsrhpold $
hpere110 dhpere110 dhpere010 dhpere010d hpere010 dhpere011 $
y y111 y020 y121 y220 y221 y222 yl021 yl022 yl122 yl222 yr021 yr122 yr221 yr321 y_s $
sle wy lurharm nawru w w_apc winf l lf lu hpere totalh wtotalh popw popt part k iq iy sr wsr $
dummy wsrres010 wsrres110 wsrres010d wsrres011 sr110 sr010 sr010d sr011 srhp wsrhp srkf wsrkf $
mpopf mpoptf wpopw wpopt partres parts dnawru hpereresnew hperehp whperehp lfss lp2 wlp2 $
totalhs wtotalhs ypot iypot iypotres diypot diypotres dep ygap lgap lurgap hperegap partgap $
totalhgap part_mt hpere_mt l_mt totalh_mt wypot wk wl lpepot lphpot wlpepot wlphpot $
khdeep kldeep ypotlp ypoth ypotk ypotsold ypots wypotl wypoth wypotk wypotsold wypots $
srfgapold srfgap logy lyhp yhp_ wyhp_ ygaphp_ whpere wh_ erate pps gdpdefle nomye nulc dlur $
gw in pi wsrres010s sr010s popwf poptf dhpere hpereres dhpereres010 hperes srgapold srgap $
yf_s gdp trend_gdp $
ypott5 kt5 iqt5 iypott5 yt5 ygapt5 srt5 logy10 totalhst10 partst10 srhpt10 hperehpt10 sr010st10 sr011t10 $
partM partsM partnonM partsnonM partst10nonM popwM popwnonM LFM LFnonM $
l_cb l_cb_hp l_cb_hpt10 ratio_cb ratio_cb_hp ratio_cb_hpt10 l_lux l_luxs





	*I* data is imported from different sources
	*I* the number 1 stands for _lu, first series described above, and so on
	*I* you need to open the file, say which series are in that file and close again
	*I* the / stands for the period which we don't define (other possibilities would be 1960:1 2015:1)

* AMECO data:
OPEN DATA AMECO_2018_II_final.rat
data(format=rats) / 1 2 3 4 5 6 7 8 9 10  15 16 17 18 19 20 24
close data

* CSM/AWG PARTS
OPEN DATA csmdpart2018.rat
data(format=rats) / 21
close data

* POPW:
OPEN DATA POP2017+US2018.RAT
data(format=rats) / 11 12
close data

if .not.TFPinput {
	if yf<=6 {

		* NAWRU t+5:
		OPEN DATA NAWRU_2018_II_final.rat
		data(format=rats) / 13
		close data

* TFP KF t+5:
		OPEN DATA SRKf_2018_II_final.rat
		data(format=rats) / 14
		close data
	display " !!!!! t+5 framework !!!!! "

	}
	else {

		* NAWRU t+10:
		OPEN DATA NAWRU_tp10_2018_II_final.rat
		data(format=rats) / 13
		close data

		* TFP KF t+10:
		OPEN DATA SRKf_tp10_2018_II_final.rat
		data(format=rats) / 14
		close data
	display " !!!!! t+10 framework !!!!! "
	}
   }

if co(ic) == 'de' {
* MIGRATION DATA:
OPEN DATA migration_2018_II_final.rat
data(format=rats) / 22 23
close data
		}

if co(ic) == 'lv' {
* DEPRECIATION DATA:
OPEN DATA AMECO_2018_II_final.rat
data(format=rats) / ee_iq lt_iq ee_kt lt_kt
close data
	}


	*I* the EU15 Member states and the US start in 1965 and the New Member states in 1995:

if   co(ic) == 'be' .or. co(ic) == 'dk' .or. co(ic) == 'de' .or. co(ic) == 'ie' $
.or. co(ic) == 'el' .or. co(ic) == 'es' .or. co(ic) == 'fr' .or. co(ic) == 'it' $
.or. co(ic) == 'lu' .or. co(ic) == 'nl' .or. co(ic) == 'at' .or. co(ic) == 'pt' $
.or. co(ic) == 'fi' .or. co(ic) == 'se' .or. co(ic) == 'uk' .or. co(ic) == 'us'{
	compute starty    = 1965
	compute startlogy = 1960
	compute startsrkf = 1980
   	}
else {
	compute starty    = 1995
	compute startlogy = 1995
	compute startsrkf = 1995
	}

display "start year: " starty

*I* after reading in the data we name the data


** The variables that are not used in RATS for the moment but are 'transported' to CONSTRUCT together with the results:
*----------------------------------------------------------------------------------------------------------------------
set erate       = [series](15)			;* exchange rates
set pps         = [series](16)			;* PPS
set gdpdefle    = [series](17)			;* the GDP deflator (euro)
set nomye       = [series](18)			;* Nominal GDP in euro used for weighting in CONSTRUCT
set nulc        = [series](19)			;* Nominal Unit Labour Cost

* GDP
*-------

set y           = [series](1)			;* gdp constant prices
set wy          = (y/y{1}-1)*100		;* growth in gdp


* LABOUR
*---------

* unemployment

set lurharm     = [series](5)  / 100           	;* harmonised unemployment rate
set dlur    	= lurharm-lurharm{1}
set nawru       = [series](13) / 100   	;* nawru from KF gap program
print / lurharm nawru

* wages

set w           = [series](6)              	;* Nominal compensation per employee (wages)
set gw		= (w/w{1} - 1) * 100           	;*
set winf        = gw - gw{1}             	;* wage inflation

* employment

set l = [series](8)                    ;* employment series. NB: National accounts domestic concept for all countries
set lf          = l /(1-lurharm)		   ;* labor force

* we have national and domestic employment. the difference are the cross border workers.
* for Luxembourg we use national employment, while for all other we use domestic employment

if co(ic) == 'lu' {
   set l_lux = [series](24)  	         ;* employment series. NB: National accounts national concept for all countries
   set l_cb = l - l_lux
   set ratio_cb = l_cb/l ;* ratio of cross-border workers
   set lf = l_lux/(1-lurharm)
   }


set lu          = lurharm*lf                   	;* consistent unemployment, may differ from AMECO series (which is not read for that reason) not used?

* civil employment      			;*  we use SLE for the EU15 MSs and SLED for the New MSs as this variable for those counries is often not available.

if   co(ic) == 'be' .or. co(ic) == 'dk' .or. co(ic) == 'de' .or. co(ic) == 'ie' $
.or. co(ic) == 'el' .or. co(ic) == 'es' .or. co(ic) == 'fr' .or. co(ic) == 'it' $
.or. co(ic) == 'lu' .or. co(ic) == 'nl' .or. co(ic) == 'at' .or. co(ic) == 'pt' $
.or. co(ic) == 'fi' .or. co(ic) == 'se' .or. co(ic) == 'uk' .or. co(ic) == 'us'{

	set sle	= [series](20)

   	}
else {
	set sle 	= l
	}


* hours worked

set hpere       = [series](7)    		;* Hours worked, from AMECO
set totalh      = hpere * l			;* total hours worked
set wtotalh     = 100* (totalh/totalh{1} - 1)	;* growth in total hours worked


* population of working age

set popw        = [series](9)                  ;* AMECO population of working age
set popt        = [series](10)                 ;* AMECO total population


* participation rate

set part        = 100* lf / popw		;* participation rate



* CAPITAL
*----------

set k           = [series](4)			;* capital stock
set iq          = [series](2)			;* investment into capital, capital stock formation
set iy          = iq/y				;* investment to gdp
set in          = [series](3)			;* nominal capital stock formation
print / k

*I* for Ireland there has been a re-valuation of the capital stock to include aircraft leasing.
*I* this is not yet visible in the ameco capital stock series, and therefore we make an adjustment here.
*I* on 29/9/2016 it is believed that capital stock goes up by 53.7% in 2015 and remains at this higher level from then on.
*I* as on Autumn 2018 another modification to this procedure was made, based on country specificity for Ireland

if co(ic) == 'ie' {

* calculate some additional variables
   set k_ori = k
   set k_difference = k-k{1}    		;* = iq - cfc
   set dep_ori  = (iq-(k-k{1}))/k{1} ;
   set dep_difference = dep_ori - dep_ori{1}
   set outturny = %if(abs(dep_difference) < 0.00000001,time,%NA)
   sstats(minimum) / outturny>>outturnyear2
   compute outturnyear2 = outturnyear2 + 1959
   compute outturnyear = fix(outturnyear2)
   display outturnyear changey-2
*** remark: outturn year is most of the time equal to t-1

* actual adjustment:
* cso estimate of the increase in the K stock for 2015
   set k 2015:1 2015:1 = 1.532*k{1} ;
* after 2015, until the outturn year, the iq and cfc series are correct, they relate to the new capital stock
  set k 2016:1 outturnyear:1 = k{1} + k_difference
* when there is no info on cfc, a constant dep rate is assumed for these years
  set dep     = (iq-(k-k{1}))/k{1} ;
  set dep outturnyear:1 changey:1     = dep{1}
  set k outturnyear:1 changey:1 = iq + (1-dep)*k{1}
print / k_difference k k_ori dep
display changey
}

if co(ic) == 'lv' {

	*I* depreciation rate is calculated based on investment and capital information
	*I* and then kept constant from the forecast starting

   set dep_ee                      = (ee_iq-(ee_kt-ee_kt{1}))/ee_kt{1}
   set dep_ee changey:1 endy:1     = dep_ee{1}
   set dep_lt                      = (lt_iq-(lt_kt-lt_kt{1}))/lt_kt{1}
   set dep_lt changey:1 endy:1     = dep_lt{1}

   set dep = (dep_ee + dep_lt)/2  ;* average dep of LT and EE
   *set dep changey:1 endy:1 = dep{1}
   *set dep 2019:1 changey:1 = dep{1}
   set k_ori = k
   set k 1996:1 * = k{1}*(1-dep) + iq
print / k k_ori dep
}

* PRODUCTIVITY (SOLOW RESIDUAL)
*---------------

set sr          = log(y/(totalh**.65*k**(1-.65)))	;* solow residual (tfp) calculated

print / y totalh k part lf popw hpere l


*-------------
* 2. FORECAST EXOGENEOUS
*=========================

	*I* this part defines some forecasted values which are done outside the combined estimation

* SR - Solow Residual
*------
set wsr                      = sr-sr{1}

	*I* this old way is not used anymore as such, but can be combined with the 'new' way to get a longer series
	*I* print is the command to show a series on the screen, the period of display is given by / (meaning all available periods)

set dummy = time>=42

	*I* regress the growth in tfp on a constant, on lagged growth in sr, on a dummy or MA process (=> four different possibilities)
	*I* use this regression to forecast the growth in tfp for yf extra years, starting in beginfy:1, and save the results into wsr010, wsr110 or wsr011
	*I* using these forecasted growth rates, calculate sr
	*I* for the different countries, use the correct regression result
	*I* filter the long series, to get a trend tfp (hp filtered)
	*I* give this trend tfp the same name for all countries (srhp)

if  co(ic) == 'it' .or. co(ic) == 'se' .or. co(ic) == 'uk' .or. co(ic) == 'nl' $
.or. co(ic) == 'de'.or. co(ic) == 'us'{
	boxjenk(constant,ma=1,define=x011sreq) wsr 1976:1 changey:1 wsrres011
	forecast  1 yf beginfy:1
	# x011sreq wsr011
	set(first=sr(1965:1)) sr011  1965:1 endt5:1 = sr011{1}  + %if(%valid(wsr011),wsr011,wsr)
   	filter(type=hp) sr011 1965:1 endt5:1 srhp
	set(first=sr(1965:1)) sr011t10  1965:1 endy:1 = sr011t10{1}  + %if(%valid(wsr011),wsr011,wsr)
  	filter(type=hp) sr011t10 1965:1 endy:1 srhpt10
   	}
else if co(ic) == 'at' .or. co(ic) == 'be' .or. co(ic) == 'dk' .or. co(ic) == 'el' .or. co(ic) == 'es' $
.or. co(ic) == 'fi' .or. co(ic) == 'fr' .or. co(ic) == 'ie'  .or. co(ic) == 'lu'  .or. co(ic) == 'pt' {
	linreg(define=x010sreq)  wsr 1976:1 changey:1 wsrres010
	# constant
	forecast  1 yf beginfy:1
	# x010sreq wsr010
	set(first=sr(1965:1)) sr010  1965:1 endt5:1 = sr010{1}  + %if(%valid(wsr010),wsr010,wsr)
        filter(type=hp) sr010 1965:1 endt5:1 srhp
	set(first=sr(1965:1)) sr010t10  1965:1 endy:1 = sr010t10{1}  + %if(%valid(wsr010),wsr010,wsr)
  	filter(type=hp) sr010t10 1965:1 endy:1 srhpt10
	}
else if co(ic) == 'hr' {
	linreg(define=xwsreq) wsr 1996:1 changey:1 wsrres010s
	# constant
	forecast  1 yf beginfy:1
	# xwsreq  wsr010s
	set(first=sr(1996:1)) sr010s 1996:1 endt5:1 = sr010s{1} + %if(%valid(wsr010s),wsr010s,wsr)
	filter(type=hp) sr010s 1995:01 endt5:01 srhp
	set(first=sr(1996:1)) sr010st10 1996:1 endy:1 = sr010st10{1} + %if(%valid(wsr010s),wsr010s,wsr)
	filter(type=hp) sr010st10 1995:01 endy:01 srhpt10
	}
else {
	linreg(define=xwsreq) wsr 1996:1 changey:1 wsrres010s
	# constant
	forecast  1 yf beginfy:1
	# xwsreq  wsr010s
	set(first=sr(1995:1)) sr010s 1995:1 endt5:1 = sr010s{1} + %if(%valid(wsr010s),wsr010s,wsr)
	filter(type=hp) sr010s 1995:01 endt5:01 srhp
	set(first=sr(1995:1)) sr010st10 1995:1 endy:1 = sr010st10{1} + %if(%valid(wsr010s),wsr010s,wsr)
	filter(type=hp) sr010st10 1995:01 endy:01 srhpt10
        }
 print / srhp srhpt10

set srhp t6:1 endy:1 = srhpt10
set wsrhp            = srhp-srhp{1}
print / srhp srhpt10


	*I* NEW method on tfp, used for all countries, based on the GAP program
	*I* Automatic creation of a file with TFP data input for the GAP program

if TFPinput {
	labels inputTFP(ic) ;
	# co(ic)+'_SR_loglev'

	labels hptrendTFP(ic) ;
	# co(ic)+'_HP_SR_loglev'

	set inputTFP(ic)   1965:1 dendy:1 = sr
	set hptrendTFP(ic) 1965:1 dendy:1 = srhp

	next IC
	}


	*I* the Kalman filter results from the GAP program (ex Rafal/Valerie):
set srKF   = [series](14)
set wsrKF  = srKF-srKF{1}
print / srkf wsrkf
	*I* for the old MS we extend the KF TFP with the simple HP filter TFP
if co(ic) == 'it' .or. co(ic) == 'se' .or. co(ic) == 'uk' .or. co(ic) == 'nl' $
.or. co(ic) == 'de'.or. co(ic) == 'us' .or. co(ic) == 'at' .or. co(ic) == 'be' $
.or. co(ic) == 'dk' .or. co(ic) == 'el' .or. co(ic) == 'es' .or. co(ic) == 'fi' $
.or. co(ic) == 'fr' .or. co(ic) == 'ie'  .or. co(ic) == 'lu'  .or. co(ic) == 'pt'{
	set wsrkf 1965:1 startsrkf:1 = wsrhp
	until %valid(srkf(1965:1))  {
	set srkf = %if(%valid(srkf),srkf,srkf{-1}-wsrkf{-1})
	}
     }


* Population at working age
*----------
	*I* to get a long series of population, we use projections
	*I* yearly averages are calculated

set popwf = [series](11)					;* MSs growth in EUROSTAT working population forecast (values at 1st January), for US: CENSUS (july-july)
set poptf = [series](12)					;* MSs growth in EUROSTAT total population forecast (values at 1st January), for US: CENSUS  (july-july)

if co(ic) == 'us' {
   	set mpopf       = popwf/popwf{1}          ;* Census 2015 projections - pop working age 15-74
   	set mpoptf      = poptf/poptf{1}          ;* Census 2015 projections - total population
display "correct us"
	}
else {
	set mpopf       = (popwf{-1}+popwf{0})/(popwf{0}+popwf{1})  	;* modified EUROSTAT working population forecast
	set mpoptf      = (poptf{-1}+poptf{0})/(poptf{0}+poptf{1})      ;* modified EUROSTAT total population forecast
display " not correct us"
	}


set popw beginfy:1 endy:1    = popw{1} * mpopf
set wpopw                    = 100* (popw/popw{1} - 1)

set popt beginfy:1 endy:1    = popt{1} * mpoptf
set wpopt                    = 100* (popt/popt{1} - 1)
print 2014:1 2025:1 wpopw popwf mpopf




* Smoothed participation rate
*----------


* in the light of the refugee/migrant crisis we want to adjust trend part for DE

if co(ic) == 'de' {

	*I* participation rates of migrants and non-migrants

set partM = [series](22)*100			;* migrant participation rate
set partM changey:1+4 * = partM{1} + 0.5*(partM{1}-partM{2}) + 0.5*(partM{2}-partM{3})
set partSM = partM				;* trend migrant participation rate = actual rate

	*I* population at working age for migrants and non-migrants

set popwM = [series](23)/1000			;* migrant population at working age
* I assume that after 2023 (t+5) no new migrants arrive (!) and that all of them stay in the 'migrant' group for several years
set popwM changey:1+4 * = popwM{1}

	*I* labour force of migrants and non-migrants

set LFM * 2014:1 = 0.			;* migrant labour force
set LFM 2015:1 * = popwM * partM/100
set LFnonM = lf - LFM				;* non-migrant labour force

set partnonM = part				;* non-migrant participation rate
set popwnonM = popw-popwM			;* non-migrant population at working age
set partnonM 2015:1 changey:1 = LFnonM / (popwnonM)*100

print	/ part partM partsM

		}


	*I* participation rate is calculated using the exogenously forecasted series on popw and lf
set part    = 100*( lf / popw ) 			;*participation rate, recalculated
*print / part
display 'part' co(ic)

	*I* find the best ARIMA proces to explain participation in the past

* first set of EU15+US and then NMS

if co(ic) == 'de' .or.co(ic) == 'pt' {
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# part{1}
	}
else if co(ic) == 'nl' .or. co(ic) == 'el' {
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# constant part{1}
  	}
else if co(ic) == 'at' {
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# part{1 to 2}
  	}
else if co(ic) == 'it' {
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# constant time part{1}
	}
else if co(ic) == 'fr' {
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# constant part{1 to 2}
	}
else if co(ic) == 'dk'.or. co(ic) == 'fi' .or. co(ic) == 'ie' .or. co(ic) == 'uk'{
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# constant part{1 to 2}
	}
else if co(ic) == 'se' .or. co(ic) == 'lu' {
   	linreg(define=xparteq) part 1965:1 changey:1 partres
   	# constant part{1 to 2}
	}
else if co(ic) == 'be' .or. co(ic) == 'es' .or. co(ic) == 'us'{
   	linreg(define=xparteq) part 1990:1 changey:1 partres
   	# constant part{1 to 3}
   	}
else if co(ic) == 'ro' .or. co(ic) == 'lt' .or. co(ic) == 'ee' .or. co(ic) == 'hr' .or.  co(ic) =='lv' $
 .or.  co(ic) =='pl' {
  	linreg(define=xparteq) part 1995:1 changey:1 partres
  	# constant part{1}
  	}
else if co(ic) == 'bg' .or. co(ic) == 'sk' .or. co(ic) == 'cz' .or. co(ic) == 'hu' .or. co(ic) == 'cy'  {
  	linreg(define=xparteq) part 1995:1 changey:1 partres
  	# constant part{1 to 2}
  	}
else if co(ic) == 'si' .or. co(ic) == 'mt' {
  	linreg(define=xparteq) part 1995:1 changey:1 partres
  	# part{1 to 2}
  	}


*print / partres

	*I* use this best proces to forecast the series

forecast  1 yf beginfy:1
# xparteq part
print / part


	*I* filter this long series to get the trend
	*I* combine t+5 and t+10 so that t+5 stays as the original
	*I* first create the t+5 series, then the t+10 series and merge


if co(ic) == 'de' {
	*I* calculate the non migrant participation rate as a part of total actual participation rate

set partnonM 2015:1 * = part*popw/(popw-popwM) - partM*popwM/(popw-popwM)

	*I* filter the non-migrant participation rate

filter(type=hp,tuning=10) partnonM starty:1 endt5:1 partsnonM
filter(type=hp,tuning=10) partnonM starty:1 endy:1 partst10nonM

	*I* calculate total trend participation rate based on migrant and non-migrant trend

set partS = partsnonM
set partS 2015:1 endt5:1 = partsnonM*(popwnonM/popw) + partsM*(popwM/popw)
set partSt10 = partst10nonM
set partSt10 2015:1 endy:1 =  partsnonM*(popwnonM/popw) + partsM*(popwM/popw)

*
graph(style=line, header="Participation series " + co(ic), key=below) 4
# partS 2000:1 endt5:1
# partnonM 2014:1 endt5:1
# part 2000:1 2014:1
# part 2014:1 endt5:1


		}
else {
	*I* for all other countries
	*I* filter this long series to get the trend
	*I* combine t+5 and t+10 so that t+5 stays as the original
	*I* first create the t+5 series, then the t+10 series and merge

filter(type=hp,tuning=10) part starty:1 endt5:1 parts
filter(type=hp,tuning=10) part starty:1 endy:1 partst10

print / parts partst10
	}


if co(ic) == 'us' {
set partst10 t6:1 endy:1    = partst10{1} * (1.+ 0.)
	}
else {
set partst10 t6:1 	t6:1    = partst10{1} * (1. + (0.25*[series](21) + 0.75*(partst10{1}/partst10{2}-1)))
set partst10 t6:1+1 	t6:1+1    = partst10{1} * (1. + (0.5* [series](21) + 0.5* (partst10{2}/partst10{3}-1)))
set partst10 t6:1+2 	t6:1+2    = partst10{1} * (1. + (0.75*[series](21) + 0.25*(partst10{3}/partst10{4}-1)))
set partst10 t6:1+3 	endy:1    = partst10{1} * (1.+ [series](21))
	}



print / parts partst10
set parts t6:1 endy:1 = partst10



* NAWRU: **** NEW end rule Spring 2014:
*----------
	*I* in the t+5 framework (yf<4) we use an extension rule; "end rule"
	*I* in t+10 the nawru series is complete and long in the dataset

if yf<=6 {
	set nawru beginfy:1 beginfy:1 = nawru{1}+.5*(nawru{1}-nawru{2})
	set nawru beginfy:1+1 endy:1  = nawru{1}
	}
set dnawru                   = nawru - nawru{1}

*===========
* Autumn Final 2018
* since the wage indicator gives the wrong signal for IE nawru, replace the nawru by a simple HP (lurharm)
*===========

if co(ic) == 'ie' {
set lurori = lurharm
  	linreg(define=lurharmeq) lurharm 1965:1 changey:1 lurres
  	# lurharm{1 to 2} constant

   forecast  1 yf beginfy:1
   # lurharmeq lurharm
*print / lurharms lurori nawru

filter(type=hp,tuning=10) lurharm 1965:1 endt5:1 lurharms

if yf<=6 {
	set lurharms beginfy:1 beginfy:1 = lurharms{1}+.5*(lurharms{1}-lurharms{2})
	set lurharms beginfy:1+1 endy:1  = lurharms{1}

graph(style=line, header="Unemployment series " + co(ic), key=below) 4
# lurharm 2000:1 changey:1
# lurharm changey:1 endy:1
# lurharms 2000:1 endy:1
# nawru 2000:1 endy:1

set nawru = lurharms
}
  	}


* HOURS
*------------
** Direct projection

	*I* find the best ARIMA proces to explain hours worked in the past
	*I* use this best proces to forecast the series
	*I* filter this long series to get the trend
	*I* for some NMS, we have a different approach, due to the shorter time series
display 'hpere' co(ic)

set dhpere = hpere - hpere{1}
print / dhpere hpere


* first set of EU15+US and then NMS

if co(ic) == 'pt' .or. co(ic) == 'be' .or. co(ic) == 'el' .or. co(ic) == 'lu' .or. co(ic) == 'nl' $
 .or. co(ic) == 'dk'  .or. co(ic) == 'ie'  .or. co(ic) == 'de'  .or. co(ic) == 'uk' {
     	linreg(define=xhpereeq) hpere 1976:1 changey:1 hpereres
     	# constant hpere{1}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
     	}
else if co(ic) == 'us' .or. co(ic) == 'at' .or. co(ic) == 'fr' .or. co(ic) == 'es' .or. co(ic) == 'it' $
.or. co(ic) == 'fi' {
     	linreg(define=xhpereeq) hpere 1976:1 changey:1 hpereres
     	# constant hpere{1 to 2}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
     	}
else if co(ic) == 'se' {
     	linreg(define=xhpereeq) hpere 1976:1 changey:1 hpereres
     	# hpere{1 to 2}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
     	}
else if co(ic) == 'cz'.or. co(ic) == 'cy'.or. co(ic) == 'hu' .or. co(ic) == 'si' {
   	linreg(define=xhpereeq) hpere 1995:1 changey:1 hpereres
   	# constant hpere{1}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
	}
else if co(ic) == 'bg'  {
   	linreg(define=xhpereeq) hpere 1995:1 changey:1 hpereres
   	# constant hpere{1 to 2}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
	}
else if  co(ic) == 'pl' {
   	linreg(define=xhpereeq) hpere 1995:1 changey:1 hpereres
   	# hpere{1 to 2}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
	}
else if co(ic) == 'mt' .or. co(ic) == 'ro' .or. co(ic) == 'sk' .or. co(ic) == 'lt' .or. co(ic) == 'ee' $
 .or. co(ic) == 'lv' .or. co(ic) == 'hr' {
   	linreg(define=xhpereeq) hpere 1995:1 changey:1 hpereres
   	# hpere{1}
	forecast  1 yf beginfy:1
	# xhpereeq hpere
	}


set dhpere = hpere - hpere{1}

filter(type=hp,tuning=10) hpere starty:1 endt5:1 hperehp

	*I* apply a stabilisation rule from t+6 onwards
filter(type=hp,tuning=10) hpere starty:1 endy:1 hperehpt10
set hperehpt10 t6:1 endy:1    = 1.5* hperehpt10{1} - 0.5* hperehpt10{2}
set hperehp t6:1 endy:1 = hperehpt10
print 2000:1 endy:1 hpere hperehp

set whperehp                 =  (hperehp/hperehp{1} - 1)

* CROSS-BORDER WORKERS
*------------
* in the case of LU we need to add cross-border workers

if co(ic) == 'lu' {
	*I* find the best ARIMA proces to explain the cross border worker ratio in the past
	*I* use this best proces to forecast the series
	*I* filter this long series to get the trend

         linreg(define=xCBeq) ratio_cb 1978:1 changey:1 ratiocb_res
         # ratio_cb{1 to 2}
    forecast  1 yf beginfy:1
    # xCBeq ratio_cb
filter(type=hp,tuning=10) ratio_cb starty:1 endt5:1 ratio_cb_hp

	*I* apply a stabilisation rule from t+6 onwards
filter(type=hp,tuning=10) ratio_cb starty:1 endy:1 ratio_cb_hpt10
set ratio_cb_hpt10 t6:1 endy:1    = 1.5* ratio_cb_hpt10{1} - 0.5* ratio_cb_hpt10{2}
set ratio_cb_hp t6:1 endy:1    = ratio_cb_hpt10

graph(style=line, header="ratio of employment of cb " + co(ic), key=below) 2
# ratio_cb 1965:1 endt5:1
# ratio_cb_hp 1965:1 endt5:1

}



* TOTALH
*------------

	*I* create related trend series



if co(ic) == 'lu' {
	*I* extend the seperate series

   set l_lux      = part/100*popw*(1-lurharm)
   set l_cb       = l_lux*ratio_cb/(1-ratio_cb)
   set l          = l_lux+l_cb
   set totalh     = l*hpere
	*I* create related trend series

   set l_luxs     = parts/100*popw*(1-nawru)
   set l_cb_hp    = l_luxs*ratio_cb_hp/(1-ratio_cb_hp)
   set lfss       = parts/100 *popw			;*trend labour force, only includes luxembourgish!
   set lp2        = l_luxs+l_cb_hp     ;*trend employment
   set totalhs    = lp2*hperehp        ;*trend total hours worked
}
else {
   set lfss                  = parts/100 *popw			;*trend labour force, includes all
   set lp2                   = lfss*(1-nawru)			;*trend employment
   set totalhs               = lp2*hperehp			;*trend total hours worked
}
set wtotalhs                 = 100* (totalhs/totalhs{1} - 1)	;*growth in trend total hours worked
set wlp2                     = 100* (lp2/lp2{1}-1)		;*growth in trend labour force participation

	*I* create a totalhs specific for the t+10
if co(ic) == 'lu' {
  set l_cb_hpt10            = (partst10/100*popw*(1-nawru))/(1-ratio_cb_hp)*ratio_cb_hp
  set totalhst10 	          = (partst10/100*popw*(1-nawru)+l_cb_hpt10)*hperehpt10
}
else {
   set totalhst10 	        = partst10/100*popw*(1-nawru)*hperehpt10
}


print / partst10 popw nawru ratio_cb_hpt10 hperehpt10



* I/YPOT
*------------

	*I* investment is forecasted using I/Ypot ratio
	*I* calculate potential output thus far
	*I* calculate I/Ypot


set ypot                     = totalhs**.65*k**(1-.65)*exp(srKF)
set iypot                    = 100* (iq/ypot)


** Direct projection

	*I* find the best ARIMA proces to explain I/Ypot in the past
display 'IYPOT' co(ic)

if co(ic)=='pt' .or. co(ic) == 'nl' .or.co(ic)=='de'.or.co(ic)=='fr'.or.co(ic)=='us'.or.co(ic)=='ie' $
.or. co(ic) == 'es' .or. co(ic)=='it'.or. co(ic)=='fi' .or. co(ic)=='dk' {
  	linreg(define=xiypoteq) iypot 1975:1 changey:1 iypotres
  	# constant iypot{1 to 2}
  	}
else if co(ic)=='lu'.or.co(ic)=='be'.or.co(ic)=='at' .or. co(ic)=='se'{
  	linreg(define=xiypoteq) iypot 1975:1 changey:1 iypotres
  	# constant iypot{1}
  	}
else if co(ic)=='uk'{
  	linreg(define=xiypoteq) iypot 1975:1 changey:1 iypotres
  	# constant iypot{1 to 3}
  	}
else if co(ic)=='el'{
  	linreg(define=xiypoteq) iypot 1975:1 changey:1 iypotres
  	# constant iypot{1 to 4}
  	}
else if co(ic) == 'cy' .or. co(ic) == 'lv' .or. co(ic) == 'pl'$
 .or. co(ic) == 'bg' .or. co(ic) == 'si' .or. co(ic) == 'hr'{
  	linreg(define=xiypoteq) iypot 1991:1 changey:1 iypotres
  	# constant iypot{1 to 2}
  	}
else if co(ic) == 'sk'.or.co(ic)=='ro' .or. co(ic) == 'mt' $
.or. co(ic) == 'cz' .or. co(ic) == 'lt'  .or. co(ic) == 'hu' {
  	linreg(define=xiypoteq) iypot 1991:1 changey:1 iypotres
  	# constant iypot{1}
  	}
else {
 	linreg(define=xiypoteq) iypot 1991:1 changey:1 iypotres
 	# constant iypot{1 to 3}
 	}




	*I* use this best proces to forecast the series

forecast  1 yf beginfy:1
# xiypoteq iypot

print / ypot iypot

set ypott10                  = totalhst10**.65*k**(1-.65)*exp(srKF)
set iypott10                 = iypot

	*I* as agreed at the EPC, there is an exception for DE
	*I* IYPOT of DE linearly converging to the EA12exclDE average in t+10, but over ten years (so by t+15, agreed after Spring 2014)
 *I* change the target + the years
 *I* last update: Autumn 2018 Final

if co(ic) == 'de' {
   compute targetiypot     = 21.2
   set iypott10 t6:1 2033:1 = iypott10(2022:1) + (time - time(2022:1))/10. * (targetiypot - iypott10(2022:1))

   }

	*I* as agreed at the EPC, there is an exception for MT
	*I* rule: linearly convergence to the EU15 t+10 average (with adjusted DE) in ten years after the mid term (so in t+15)
	*I* last update: Autumn 2018 Final

if co(ic) == 'mt'{
   compute targetiypot = 20.6
   set iypott10 t6:1 2033:1 = iypott10(2022:1) + (time - time(2022:1))/10. * (targetiypot - iypott10(2022:1))

   }

* DEPreciation rate
*-------------------

	*I* depreciation rate is calculated based on investment and capital information
	*I* and then kept constant from the forecast starting

set dep                      = (iq-(k-k{1}))/k{1}
set dep changey:1 endy:1     = dep{1}
print / dep
*print / dep [series](25)

* GAP closure rule
*-------------------

	*I* the gap closure rule states that if the gaps are not closed before the end of the medium term,
	*I* they should be mechanically closed by that time

	*I* start by calculating the output gap

set ygap                         = 100* (y/ypot-1);

	*I* set all gaps equal to zero
set ygap      beginfy:1 endy:1	 = 0.
set lgap      beginfy:1 endy:1	 = 0.
set lurgap    beginfy:1 endy:1	 = 0.
set hperegap  beginfy:1 endy:1	 = 0.
set partgap   beginfy:1 endy:1	 = 0.
set totalhgap beginfy:1 endy:1   = 0.

	*I* compute the year of the mid-term

*compute endmty                   = changey+3

	*I* clear part and hpere

set part  beginfy:1 endy:1       = %na
set hpere beginfy:1 endy:1       = %na

	*I* the following is the default 3Y rule, in which the gap will close at the end of the mid term 'closey'

compute closey                   = changey+3

	*I* from the first year of the forecast, until the closing year only part of the gap is taken
	*I* for example, in 2018 ygap = (2019-2018)/(10-3-5)*ygap = 1/5*gap

     set ygap     beginfy:1 closey:1 = (closey-(1959+time)) / (3.) * ygap(changey:1)
     set partgap  beginfy:1 closey:1 = (closey-(1959+time)) / (3.) * (part(changey:1)-parts(changey:1))   ;*NB: here "gap"=diff and not reldiff
     set lurgap   beginfy:1 closey:1 = (closey-(1959+time)) / (3.) * (lurharm(changey:1)-nawru(changey:1));*NB: here "gap"=diff and not reldiff
     set HperEgap beginfy:1 closey:1 = (closey-(1959+time)) / (3.) * (hpere(changey:1)-hperehp(changey:1));*NB: here "gap"=diff and not reldiff

	*I* depending on whether the gap should be closed before the midterm, the if or else below is used
	*I* 'le' stands for less than or equal to
	*I* mid term series are defined as the original series before the start of the forecast
	*I* and as the sum of the gap and trend from the start of the forecast


   set part_mt		                = part;
   set part_mt 	 beginfy:1 endy:1 	= parts + partgap;
   set hpere_mt 	                = hpere;
   set hpere_mt	 beginfy:1 endy:1       = hperehp + hperegap;
   set lurharm	 beginfy:1 endy:1	= nawru + lurgap;
   set l_mt		                = l;


if co(ic) == 'lu' {
   set lcbgap beginfy:1 endy:1   = 0.
   set lcbgap beginfy:1 closey:1 = (closey-(1959+time)) / (3.) * (l_cb(changey:1)-l_cb_hp(changey:1));*NB: here "gap"=diff and not reldiff
   set l_lux_mt = l_lux
   set l_lux_mt beginfy:1 endy:1       = popw * part_mt/100 * (1-lurharm)
   set l_cb_mt = l_cb
   set l_cb_mt beginfy:1 endy:1     =  l_cb_hpt10 - lcbgap
   set l_mt	 beginfy:1 endy:1       = l_lux_mt + l_cb_mt ;
}
else {
   set l_mt	 beginfy:1 endy:1       = popw * part_mt/100 * (1-lurharm);
}

set totalh_mt	                        = l_mt* hpere_mt

set lgap                     		= 100* (l_mt-lp2)/lp2
set totalHgap                		= 100* (totalh_mt-totalhs)/totalhs

disp co(ic) ": gap closure in " closey; print changey:1 endy:1 ygap time part_mt parts lurharm nawru l_mt
disp co(ic) ": gap closure in " closey; print changey:1 endy:1 lp2 lgap hperegap hpere_mt hperehp totalh_mt totalhgap



*-------------
* 3. The actual MODEL, aka Program Function, SIMULATION:
*====================

	*I* this part describes the endogenous forecast, the actual model
	*I* first the different equations that are to be estimated simultaneously are described and named (e.g. KEQ)
	*I* then they are grouped, and the group is also named (e.g. POTYsr)
	*I* then this group is forecasted at the same time (yf years of forecast, print so that the results can be seen on the screen)

	*Ia* for the t+5 procedure:

FRML(IDENTITY) YPOTEQ YPOT   = totalhs**.65*K**(1-.65)*exp(srKF)
FRML(IDENTITY) KEQ K         = IQ+(1-dep)*K{1}
FRML(IDENTITY) IQEQ IQ       = iypot/100*YPOT

FRML(IDENTITY) YEQ Y         = YPOT*(1+ygap/100)
FRML(IDENTITY) SREQ SR       = log(Y/(totalh_mt**.65*K**(1-.65)))
GROUP POTYsr  YPOTEQ>>YPOT KEQ>>K IQEQ>>IQ  YEQ>>Y  SREQ>>SR   ;**MT**

FORECAST(MODEL=POTYsr,PRINT) * 6 beginfy:1

set wsr beginfy:1 endy:1   = sr - sr{1}

if co(ic)=='el' {
	set wsr beginfy:1 closey:1   = sr - sr{1}
	}
set ypott5 starty:1 endt5:1  = ypot
set kt5 starty:1 endt5:1     = k
set iqt5 starty:1 endt5:1    = iq
set iypott5 starty:1 endt5:1 = iypot
set yt5 starty:1 endt5:1     = y
set ygapt5 starty:1 endt5:1  = ygap
set srt5 starty:1 endt5:1    = sr

	*Ib* for the t+10 procedure:

if yf>6. {

	*I* for all EU15 MS except for DE, a combination of the investment and capital rule is used
   	*I* the investment rule was:
      		* FRML(IDENTITY) KEQ K         = IQ+(1-dep)*K{1}
      		* FRML(IDENTITY) IQEQ IQ       = iypot/100*YPOT
   	*I* the capital rule was:
   		* FRML(IDENTITY) KBISEQ K         = K{1} * YPOT/YPOT{1}
   		* FRML(IDENTITY) IQBISEQ IQ       = K + ((dep-1)*K{1})

	*I*  the combination is done using weights:

set w 			= 1.
set w 2024:1 endy:1 	= 0.9
set w 2025:1 endy:1 	= 0.8
set w 2026:1 endy:1 	= 0.7
set w 2027:1 endy:1 	= 0.6
set w 2028:1 endy:1 	= 0.5
set w 2029:1 endy:1 	= 0.4
set w 2030:1 endy:1 	= 0.3
set w 2031:1 endy:1 	= 0.2
set w 2032:1 endy:1 	= 0.1
set w 2033:1 endy:1 	= 0.

if co(ic) == 'it' .or. co(ic) == 'se' .or. co(ic) == 'uk' .or. co(ic) == 'nl' $
.or. co(ic) == 'us' .or. co(ic) == 'at' .or. co(ic) == 'be' $
.or. co(ic) == 'dk' .or. co(ic) == 'el' .or. co(ic) == 'es' .or. co(ic) == 'fi' $
.or. co(ic) == 'fr' .or. co(ic) == 'ie'  .or. co(ic) == 'lu'  .or. co(ic) == 'pt' {

   FRML(IDENTITY) YPOTEQ YPOTt10   = totalhst10**.65*K**(1-.65)*exp(srKF)
   FRML(IDENTITY) IQ1EQ IQ1       = iypott10/100*YPOTt10
   FRML(IDENTITY) IQ2EQ IQ2       = K{1} *(YPOTt10/YPOTt10{1} + dep- 1.)
   FRML(IDENTITY) KmixEQ K        = (w*IQ1 + (1-w)*IQ2) +(1-dep)*K{1}


   FRML(IDENTITY) YEQ Yt10         = YPOTt10*(1+ygap/100)
   FRML(IDENTITY) SREQ SR       = log(Yt10/(totalh_mt**.65*K**(1-.65)))

   GROUP POTYmixsr  YPOTEQ>>YPOTt10 KmixEQ>>K IQ1EQ>>IQ1 IQ2EQ>>IQ2  YEQ>>Yt10  SREQ>>SR

   FORECAST(MODEL=POTYmixsr,PRINT) * yf beginfy:1

   set iq beginfy:1 endy:1 	= (w*IQ1 + (1-w)*IQ2)
   set iypott10 beginfy:1 endy:1 	= iq / ypott10 *100
print 2020:1 2040:1 IQ IQ1 IQ2 w ypott10 k dep
        }

else  {

   FRML(IDENTITY) YPOTEQ YPOTt10   = totalhst10**.65*K**(1-.65)*exp(srKF)
   FRML(IDENTITY) KEQ K         = IQ+(1-dep)*K{1}
   FRML(IDENTITY) IQEQ IQ       = iypott10/100*YPOTt10

   FRML(IDENTITY) YEQ Yt10         = YPOTt10*(1+ygap/100)
   FRML(IDENTITY) SREQ SR       = log(Yt10/(totalh_mt**.65*K**(1-.65)))

   GROUP POTYsr  YPOTEQ>>YPOTt10 KEQ>>K IQEQ>>IQ  YEQ>>Yt10  SREQ>>SR

   FORECAST(MODEL=POTYsr,PRINT) * yf beginfy:1

		}

** for the variables for which we created t+10 variables, change the t+5 variables into t+10 variables from t6 onwards
set ypot t6:1 endy:1 = ypott10
set iypot t6:1 endy:1 = iypott10
set y t6:1 endy:1 = yt10

** for the variables for which we did not create specific t+10 variables, change the 'new' variables back into t+5 variables before t+6
set k starty:1 t6:1-1 = kt5
set iq starty:1 t6:1-1 = iqt5
set ygap starty:1 t6:1-1 = ygapt5
set sr starty:1 t6:1-1 = srt5
set wsr beginfy:1 endy:1   = sr - sr{1}
if co(ic)=='el' .or. co(ic)=='ro'  {
	set wsr beginfy:1 closey:1   = sr - sr{1}
	}
    }
	*Ib* the end of the t+10 program


print 2010:1 endy:1 ypot ypott5 ypott10
print 2010:1 endy:1 totalhst10 k srkf  iq dep iypott10


	*I* the final used variables are created
	*I* be careful with the estimation of growth rates using log values

set wypot                    = (ypot/ypot{1}-1)*100

set wk                       = (k/k{1}-1)*100
set wl                       = (l/l{1}-1)*100
set wy                       = (y/y{1}-1)*100
print / ypotk
if co(ic) == 'lu' {
set lpepot                   = ypot / (lp2+l_cb_hp)
}
else {
set lpepot                   = ypot / lp2
}
set lphpot                   = ypot / totalhs
set wlpepot                  = 100* (lpepot/lpepot{1} - 1)
set wlphpot                  = 100* (lphpot/lphpot{1} - 1)

set khdeep                   = (1-.65) * (wk - wtotalhs)
set kldeep                   = (1-.65) * (wk - wl)

if co(ic) == 'lu' {
set ypotlp                   = (lp2+l_cb_hp)**.65
}
else {
set ypotlp                   = lp2**.65
}

set ypoth                    = totalhs**.65
set ypotk                    = k**(1-.65)
set ypotsOLD                 = exp(srhp)
set ypots                    = exp(srKF)

set wypotl                   = (ypotlp/ypotlp{1}-1)*100
set wypoth                   = (ypoth/ypoth{1}-1)*100
set wypotk                   = (ypotk/ypotk{1}-1)*100

set wypotsOLD                = (ypotsOLD/ypotsOLD{1}-1)*100
set wypots                   = (ypots/ypots{1}-1)*100

* ygap ~= totalhgap + lgap
set srgapOLD                = (exp(sr)/exp(srhp)-1)*100
set srgap                   = (exp(sr)/exp(srKF)-1)*100
set lgap                     = .65*(l/lp2-1)*100
set totalhgap                = .65*(totalh/totalhs-1)*100

set lurgap                   = (nawru-lurharm)*100






*--------------------------
* 4. TREND GDP
*============================

	*I* in this part Yhp is calculated as a stochastic extension of GDP

	*I* Choice of process according to the country
   *I* make sure that t+5 and t+10 are identical and thus repeat the process twice

   *I* for t<5
if co(ic) == 'be' {
  	@bjfore(trans   = log,  diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endt5:1 yl221      ;* BE
	set yl221                   = %if(%valid(yl221),yl221,y)
	set logy     = log(yl221)
   }
else if co(ic) == 'dk' {
	@bjfore(trans   = log,  diffs = 2, mas = 1,          noconstant) y beginfy:1 endt5:1 yl021      ;* DK
	set yl021                   = %if(%valid(yl021),yl021,y)
	set logy = log(yl021)
   }
else if co(ic) == 'de' .or. co(ic) == 'us'{
	@bjfore(trans   = root, diffs = 2, ars = 1, mas = 2, noconstant) y beginfy:1 endt5:1 yr122      ;* DE, US
	set yr122                   = %if(%valid(yr122),yr122,y)
	set logy     = log(yr122)
   }
else if co(ic) == 'el' {
	@bjfore(trans   = root, diffs = 2, mas = 1,          noconstant) y beginfy:1 endt5:1 yr021      ;* EL
	set yr021                   = %if(%valid(yr021),yr021,y)
	set logy     = log(yr021)
  }
else if co(ic) == 'es' {
	@bjfore(trans   = log,  diffs = 2, ars = 2, mas = 2, noconstant) y beginfy:1 endt5:1 yl222      ;* ES
	set yl222                   = %if(%valid(yl222),yl222,y)
	set logy     = log(yl222)
  }
else if co(ic) == 'fr' {
	@bjfore(trans   = log,  diffs = 2, ars = 1, mas = 2, noconstant) y beginfy:1 endt5:1 yl122      ;* FR
	set yl122                   = %if(%valid(yl122),yl122,y)
	set logy     = log(yl122)
  }
else if co(ic) == 'ie' {
	@bjfore(trans   = none, diffs = 2, ars = 2,          noconstant) y beginfy:1 endt5:1 y220       ;* IE
	set y220                    = %if(%valid(y220), y220, y)
	set logy     = log(y220)
  }
else if co(ic) == 'it' {
	@bjfore(trans   = log,  diffs = 2, mas = 2,          noconstant) y beginfy:1 endt5:1 yl022      ;* IT
	set yl022                   = %if(%valid(yl022),yl022,y)
	set logy     = log(yl022)
  }
else if co(ic) == 'lu' {
	@bjfore(trans   = none, diffs = 1, ars = 1, mas = 1)             y beginfy:1 endt5:1 y111       ;* LU
	set y111                    = %if(%valid(y111), y111, y)
	set logy     = log(y111)
  }
else if co(ic) == 'nl' {
	@bjfore(trans   = none, diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endt5:1 y221       ;* NL
	set y221                    = %if(%valid(y221), y221, y)
	set logy     = log(y221)
  }
else if co(ic) == 'at' {
	@bjfore(trans   = none, diffs = 2, ars = 1, mas = 1, noconstant) y beginfy:1 endt5:1 y121       ;* AT
	set y121                    = %if(%valid(y121), y121, y)
	set logy     = log(y121)
  }
else if co(ic) == 'pt' {
	@bjfore(trans   = root, diffs = 2, ars = 3, mas = 1, noconstant) y beginfy:1 endt5:1 yr321      ;* PT
	set yr321                   = %if(%valid(yr321),yr321,y)
	set logy     = log(yr321)
  }
else if co(ic) == 'fi' {
	@bjfore(trans   = none, diffs = 2,                   noconstant) y beginfy:1 endt5:1 y020       ;* FI
	set y020                    = %if(%valid(y020), y020, y)
	set logy     = log(y020)
  }
else if co(ic) == 'se' {
	@bjfore(trans   = root, diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endt5:1 yr221      ;* SE
	set yr221                   = %if(%valid(yr221),yr221,y)
	set logy     = log(yr221)
  }
else if co(ic) == 'uk'{
	@bjfore(trans   = none, diffs = 2, ars = 2, mas = 2, noconstant) y beginfy:1 endt5:1 y222       ;* UK
	set y222                    = %if(%valid(y222), y222, y)
	set logy     = log(y222)
  }
else {
	esmooth(trend=linear,estimate,smoothed=y_s,resids=errors,forecasts=yf_s,steps=6,initial=start) y 1995:1 changey:1
	set yf_s = %if(%valid(yf_s),yf_s,y)
	set logy = log(yf_s)
	}


	*I* Trend Y

filter(type=hp,tuning=100) logy startlogy:1 endt5:1 lyhp



   *I* for t>5

if yf>=6 {

if co(ic) == 'be' {
  	@bjfore(trans   = log,  diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endy:1 yl221      ;* BE
	set yl221                   = %if(%valid(yl221),yl221,y)
	set logy10     = log(yl221)
   }
else if co(ic) == 'dk' {
	@bjfore(trans   = log,  diffs = 2, mas = 1,          noconstant) y beginfy:1 endy:1 yl021      ;* DK
	set yl021                   = %if(%valid(yl021),yl021,y)
	set logy10 = log(yl021)
   }
else if co(ic) == 'de' .or. co(ic) == 'us'{
	@bjfore(trans   = root, diffs = 2, ars = 1, mas = 2, noconstant) y beginfy:1 endy:1 yr122      ;* DE, US
	set yr122                   = %if(%valid(yr122),yr122,y)
	set logy10     = log(yr122)
   }
else if co(ic) == 'el' {
	@bjfore(trans   = root, diffs = 2, mas = 1,          noconstant) y beginfy:1 endy:1 yr021      ;* EL
	set yr021                   = %if(%valid(yr021),yr021,y)
	set logy10     = log(yr021)
  }
else if co(ic) == 'es' {
	@bjfore(trans   = log,  diffs = 2, ars = 2, mas = 2, noconstant) y beginfy:1 endy:1 yl222      ;* ES
	set yl222                   = %if(%valid(yl222),yl222,y)
	set logy10     = log(yl222)
  }
else if co(ic) == 'fr' {
	@bjfore(trans   = log,  diffs = 2, ars = 1, mas = 2, noconstant) y beginfy:1 endy:1 yl122      ;* FR
	set yl122                   = %if(%valid(yl122),yl122,y)
	set logy10     = log(yl122)
  }
else if co(ic) == 'ie' {
	@bjfore(trans   = none, diffs = 2, ars = 2,          noconstant) y beginfy:1 endy:1 y220       ;* IE
	set y220                    = %if(%valid(y220), y220, y)
	set logy10     = log(y220)
  }
else if co(ic) == 'it' {
	@bjfore(trans   = log,  diffs = 2, mas = 2,          noconstant) y beginfy:1 endy:1 yl022      ;* IT
	set yl022                   = %if(%valid(yl022),yl022,y)
	set logy10     = log(yl022)
  }
else if co(ic) == 'lu' {
	@bjfore(trans   = none, diffs = 1, ars = 1, mas = 1)             y beginfy:1 endy:1 y111       ;* LU
	set y111                    = %if(%valid(y111), y111, y)
	set logy10     = log(y111)
  }
else if co(ic) == 'nl' {
	@bjfore(trans   = none, diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endy:1 y221       ;* NL
	set y221                    = %if(%valid(y221), y221, y)
	set logy10     = log(y221)
  }
else if co(ic) == 'at' {
	@bjfore(trans   = none, diffs = 2, ars = 1, mas = 1, noconstant) y beginfy:1 endy:1 y121       ;* AT
	set y121                    = %if(%valid(y121), y121, y)
	set logy10     = log(y121)
  }
else if co(ic) == 'pt' {
	@bjfore(trans   = root, diffs = 2, ars = 3, mas = 1, noconstant) y beginfy:1 endy:1 yr321      ;* PT
	set yr321                   = %if(%valid(yr321),yr321,y)
	set logy10     = log(yr321)
  }
else if co(ic) == 'fi' {
	@bjfore(trans   = none, diffs = 2,                   noconstant) y beginfy:1 endy:1 y020       ;* FI
	set y020                    = %if(%valid(y020), y020, y)
	set logy10     = log(y020)
  }
else if co(ic) == 'se' {
	@bjfore(trans   = root, diffs = 2, ars = 2, mas = 1, noconstant) y beginfy:1 endy:1 yr221      ;* SE
	set yr221                   = %if(%valid(yr221),yr221,y)
	set logy10     = log(yr221)
  }
else if co(ic) == 'uk'{
	@bjfore(trans   = none, diffs = 2, ars = 2, mas = 2, noconstant) y beginfy:1 endy:1 y222       ;* UK
	set y222                    = %if(%valid(y222), y222, y)
	set logy10     = log(y222)
  }
else {
	esmooth(trend=linear,estimate,smoothed=y_s,resids=errors,forecasts=yf_s,steps=6,initial=start) y 1995:1 changey:1
	set yf_s = %if(%valid(yf_s),yf_s,y)
	set logy10 = log(yf_s)
	}

	*I* Trend Y

filter(type=hp,tuning=100) logy10 startlogy:1 endy:1 lyhp10
set lyhp t6:1 endy:1 = lyhp10

}
set y_s                     = exp(logy)
set yhp_                    = exp(lyhp)
set wyhp_                   = 100* (yhp_/yhp_{1}-1)
set ygaphp_                 = 100* (y/yhp_ - 1)





*--------------------------
* 5. TABLES AND GRAPHS
*============================

	*I* certain tables can be made in the program
	*I* in the past tables were printed in the program and then copied
	*I* now: the results are pasted into the xls construct and tables and graphs are made automatically

set wsr                     = 100* wsr
set wsrhp                   = 100* wsrhp
set wsrKF                   = 100* wsrKF
set nawru                   = 100* nawru
set lurharm                 = 100* lurharm
set whpere                  = 100* whpere

	*I* excel gives the results per country and can still be selected at the start

if excel {
   compute xlsname          = "series"+co(ic)+".xls"
   display xlsname
   set wh_                  = wypoth - wypotl
   open copy &xlsname
   copy(org=obs,format=xls,dates) dstarty:1 dendy:1 ygaphp_ ygap wy wyhp_ wypot wypoth wypotl wh_ wypotk wypots wpopw parts nawru iypot
   close copy
   }

	*I* excelbis and ter are sometimes used by Unit A3, but not often
	*I* you need to uncomment them in the start to be able to create them

*if excelbis {
*   compute xlsname          = "seriesBIS"+co(ic)+".xls"
*   display xlsname
*   open copy &xlsname
**   copy(org=obs,format=xls,dates) dstarty:1 dendy:1 ygaphp_ ygap totalhgap srgap wy wyhp_ wypot wtotalhs wlp2 whperehp wlphpot khdeep wypots
*   copy(org=obs,format=xls,dates) 1981:1 changey:1 ygap srgap totalhgap lurgap lurharm nawru winf
*   close copy
*   }
*
*if excelter {
*   compute xlsname          = "seriesTER"+co(ic)+".xls"
*   display xlsname
*   open copy &xlsname
*   copy(org=obs,format=xls,dates) 1981:1 dendy:1 wypot wtotalhs wlp2 whperehp wlphpot khdeep wypots
*   close copy
*   }


	*I* Input to reporting tables, these tables are used by Unit A3 for the construct

do i0 = 1, nvar
	set tableaux(i0,ic)  dstarty:1 dendy:1 = %s(veccodevar(vecvar(i0)))
	set tableaux2(ic,i0) dstarty:1 dendy:1 = %s(veccodevar(vecvar(i0)))
end do i0


	*I* as a check we ask the program to display the country name so that we are sure that it has run to the end

display ic ic ic co(ic)

	*I* the loop over the countries is closed

*===================
end do  ic
*===================


	*I* Tables are created over all the countries

if TFPinput {
   print(window = 'inputTFP for use in the GAP program') / inputTFP  hptrendTFP
   }

else {
	if onecountry.or.nvar == 1 {
   	print(window = 'Selected variables') / tableaux
  		}
	else {
   	print(window = 'Display by country') / tableaux
   	print(window = 'Display by var')     / tableaux2
  		}
  }
end if




















************************ Information on revisions **************************************************************
*
****Changes in the past
* Autumn 2018:
* - remove the extension of IQ for MT (not used)
* - adjust the K stock series calculation for IE
* -
* Spring 2018:
* first round of country specificities (EPC January 2018)
* change PART for LU, and change Kstock for LV
* Spring 2017:
* - in T+10, for Italy the prudent rule is not used after t+5, but the regression result (agreed at the July 4th OGWG)
* - new AGW participation rates are available
* - sample of PART for SE was extended, so that the projection is closer to the AWG
* - new POP figures are available
* Autumn 2016:
* - kapital stock of Ireland is adjusted mechanically
* - migration effects on participation rate are added for DE
* Winter 2015-2016:
* - hpere for HR is supplied as of 2008, before 2008 we leave hpere constant
* - hpere for LV is now longer (since 1995)
* Winter 2014-2015:
* creation of one program that can produce the t+5, t+10 for all countries
*Spring 2014:
*- new hybrid Philips curve
*- new pop data from EUROSTAT
*- smoothing from ameco to europop is no longer needed
*Autumn 2013:
*- the default gap closure rule is used for all CO (3 years)
*Spring 2013:
*- population at working age is smoothed so that jumps from AMECO to ESTATs EUROPOP are avoided
*Winter 2012-2013:
*- population at working age is changed to 15-74 years
*- IYPOT equation without trend for more countries, incl. DE
*Spring 2012
*- Participation equation is slightly modified for the UK
*- Total hours worked series from TED/GGDC are used at the beginning of the series (in the past average hours series)
*- IYPOT forecast for FI: estimation period starts in 1991
*Autumn 2011
*- new GGDC hours data (version of 09-2011)
*- specification for hpere for DE AT ES has changed (common model for AT and DE, like NL for ES)
*- gap closure rule (1y for SE, kept 5y for EL)
*Spring 2011
*- hpere medium term estimates are based on longer sample (NL DE IT country specific treatment)
*- 1st run to get TFP input made easier
*- new GGDC hours data (version of 01-2011)
*- new EUROPOP10 population projections (all countries use the central scenario)
*Autumn 2010
*- KF trend TFP becomes official, series start in 1980 (spliced with HP series)
*- IE: no updated CU series, but univariate KF trend still used
*- IYPOT equation without trend
*- HperE medium term no longer fixed at 2008 value
*- new GGDC hours data (version of 09-2010)
*Spring 2010
*- PART extension without time trend
*- POPA: ES and IE use the "no-migration" variant of the EUROPOP scenario
*- TFP: KF trend method, in parallel (preparing the TFP input series, reading in the KF extracted trend)
*- corrPOPA: after forecast year, growth rates taken from EUROSTAT population projections AVERAGES
*Autumn 2009
*-  New GGDC data (version of 06-2009)
*-  PARTS for FR, PT and LU: without trend
*Spring 2009
*- some ARIMA specifications for TFP are updated
*- missing forecast years for ES on HperE (only for that forecast round)
*- new GGDC data for the preliminary (version of 01-2009)
*Autumn 2008
*- new GGDC data for the provisional (version of 09-2008)
*- update of the population projections (POP2008)
*Spring 2008
*- New GGDC data for the final
*Former changes:
*- IE: change of ARIMA TFP process  (includes a dummy)
*- Italy 1992-2008: POPA from the IT-Desk
*- Population of Working Age: update of EUROSTAT projections
*- End of Spanish non-negative gTFP rule
*- Inclusion of HperE in the model, AMECO data prolonged backward using GGDC
*- H directly smoothed
*- AMECO NETD series (Domestic National Accounts EMPL series) used for all countries
*- Trend GDP (= HP-filtered GDP) calculated inside this Rats routine
*












































































